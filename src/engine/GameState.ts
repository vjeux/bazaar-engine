import type { BoardCard, GameState, Player } from "./Engine.ts";

// Import JSON types generated by quicktype
import {
  AttributeType,
  type Card,
  type Cards,
  type Enchantments,
} from "../types/cardTypes.ts";
import type { Tier } from "../types/shared.ts";
import type {
  EncounterDays,
  FlattenedEncounter,
  Group,
} from "../types/encounterTypes.ts";
import { z } from "zod";
import { v7 as uuidv7 } from "uuid";
import { CARDS_VERSION, defaultSandstormInitialTick } from "@/lib/constants.ts";
import prand from "pure-rand";

function _createBoardCardFromCard(
  card: Card,
  tier: Tier,
  enchantment: keyof Enchantments | null = null,
  attributeOverrides: Partial<Record<AttributeType, number>> = {},
): BoardCard {
  // Initialize all AttributeType properties with undefined
  const baseAttributes: Record<AttributeType, number | undefined> =
    {} as Record<AttributeType, number | undefined>;
  for (const attribute of Object.keys(AttributeType)) {
    baseAttributes[attribute as AttributeType] = undefined;
  }

  // All cards have a CritChance base of 0
  baseAttributes.CritChance = 0;

  // Combine with other required properties
  let attributes = {
    ...baseAttributes,
    Abilities: card.Abilities || {},
    Auras: card.Auras || {},
    AbilityIds: [] as string[],
    AuraIds: [] as string[],
    TooltipIds: [] as number[],
    HiddenTags: [] as string[],
    Localization: {
      Tooltips: card.Localization.Tooltips,
      Title: {
        Text: card.Localization.Title.Text,
      },
    },
  };

  // If the provided tier is not available, default to the first tier available.
  if (!card.Tiers || !(tier in card.Tiers)) {
    // Get tier key
    const tierKeys = Object.keys(card.Tiers || {});
    tier = tierKeys[0] as Tier;
  }

  // Iterate over the tiers in order and merge their attributes until the desired tier is reached.
  for (const [tn, tierValues] of Object.entries(card.Tiers || {})) {
    attributes = {
      ...attributes,
      ...(tierValues?.Attributes ?? {}), // Spread out the attributes like DamageAmount, HealAmount, etc, so we can store and change them dynamically
      AbilityIds: tierValues?.AbilityIds || attributes.AbilityIds,
      AuraIds: tierValues?.AuraIds || attributes.AuraIds,
      TooltipIds: tierValues?.TooltipIds || attributes.TooltipIds,
    };

    if (tn === tier) {
      break;
    }
  }

  // Override the attributes
  for (const [attribute, modifier] of Object.entries(attributeOverrides)) {
    attributes[attribute as AttributeType] = modifier;
  }

  if (enchantment) {
    if (!card.Enchantments) {
      throw new Error(
        `No enchantments available for card ${card.Localization.Title.Text}`,
      );
    }
    const enchant = card.Enchantments[enchantment];
    if (!enchant) {
      throw new Error(
        `Enchantment ${enchantment} not found for card ${card.Localization.Title.Text}`,
      );
    }
    attributes = { ...attributes, ...enchant.Attributes };
    if (enchant.HasAbilities) {
      attributes.Abilities = {
        ...attributes.Abilities,
        ...enchant.Abilities,
      };
      attributes.AbilityIds = [
        ...(attributes.AbilityIds ?? []),
        ...Object.keys(enchant.Abilities),
      ];
    }
    if (enchant.HasAuras) {
      attributes.Auras = { ...attributes.Auras, ...enchant.Auras };
      attributes.AuraIds = [
        ...(attributes.AuraIds ?? []),
        ...Object.keys(enchant.Auras),
      ];
    }

    // Add enchantment tags as hidden tags
    attributes.HiddenTags = [
      ...(attributes.HiddenTags ?? []),
      ...enchant.HiddenTags,
    ];

    attributes.Localization.Tooltips = [
      ...attributes.Localization.Tooltips,
      ...enchant.Localization.Tooltips,
    ];
    attributes.TooltipIds = [
      ...(attributes.TooltipIds ?? []),
      ...enchant.Localization.Tooltips.map((tooltip) =>
        attributes.Localization.Tooltips.indexOf(tooltip),
      ),
    ];
    attributes.Localization.Title.Text = `${enchantment} ${attributes.Localization.Title.Text}`;
  }

  // Generate UUID used to identify the card in the game state
  // Need to know which card is which to do drag and drop
  const uuid = uuidv7();

  // Create the final BoardCard object with all required properties
  const result: BoardCard = {
    ...baseAttributes,
    ...attributes,
    card: card,
    uuid: uuid,
    tick: 0,
    tags: card.Tags,
    HiddenTags: attributes.HiddenTags,
    tier: tier,
    Enchantment: enchantment,
    isDisabled: false,
  };

  return result;
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function createBoardCardFromName(
  Cards: Cards,
  name: string,
  tier: Tier | null = null,
  enchantment: keyof Enchantments | null = null,
  attributeOverrides: Partial<Record<AttributeType, number>> = {},
): BoardCard {
  const CardsValues = Cards[CARDS_VERSION];
  const card = CardsValues.find((c) => c.Localization?.Title?.Text === name);
  if (!card) {
    throw new Error(`Card ${name} not found`);
  }
  return _createBoardCardFromCard(
    card,
    tier ?? card.StartingTier,
    enchantment,
    attributeOverrides,
  );
}

function createBoardCardFromId(
  Cards: Cards,
  cardId: string,
  tier: Tier | undefined,
  enchantment: keyof Enchantments | null = null,
  attributeOverrides: Partial<Record<AttributeType, number>> = {},
): BoardCard {
  const card = Cards[CARDS_VERSION].find((card) => card.Id === cardId);
  if (!card) {
    throw new Error(`Card from id ${cardId} not found`);
  }
  return _createBoardCardFromCard(
    card,
    tier ?? card.StartingTier,
    enchantment,
    attributeOverrides,
  );
}

function createBoardPlayer(
  stats: Omit<Partial<Player>, "board"> & { HealthMax: number },
  boardCards: BoardCard[],
): Player {
  return {
    HealthMax: stats.HealthMax,
    Health: stats.HealthMax,
    HealthRegen: stats.HealthRegen ?? 0,
    Shield: 0,
    Burn: 0,
    Poison: 0,
    Gold: stats.Gold ?? 0,
    Income: stats.Income ?? 0,
    Hero: "<Hero Name>",
    board: boardCards,
  };
}

function createBoardPlayerFromMonsterCard(Cards: Cards, monsterCard: Group) {
  return createBoardPlayer(
    { HealthMax: monsterCard.health },
    monsterCard.items
      .map((item) =>
        createBoardCardFromId(
          Cards,
          item.card.id,
          item.tierType,
          item.enchantmentType,
        ),
      )
      .concat(
        monsterCard.skills.map((item) =>
          createBoardCardFromId(Cards, item.card.id, item.tierType),
        ),
      ),
  );
}

function createBoardPlayerFromMonsterName(
  Cards: Cards,
  Encounters: EncounterDays,
  name: string,
) {
  for (let i = 0; i < Encounters.data.length; ++i) {
    const day = Encounters.data[i];
    for (let j = 0; j < day.groups.length; ++j) {
      const group = day.groups[j];
      for (let k = 0; k < group.length; ++k) {
        const monsterCard = group[k];
        if (monsterCard.cardName === name) {
          return createBoardPlayerFromMonsterCard(Cards, monsterCard);
        }
      }
    }
  }
  throw new Error(`Can't find a monster with name ${name}`);
}

// Define Zod schema for MonsterConfig
export const MonsterConfigSchema = z.object({
  type: z.literal("monster"),
  name: z.string(),
  day: z.number(),
});

// Infer the TypeScript type from the Zod schema
export type MonsterConfig = z.infer<typeof MonsterConfigSchema>;

export interface PlayerCardConfig {
  cardId: string;
  tier?: Tier;
  enchantment?: keyof Enchantments;
  attributeOverrides?: Partial<Record<AttributeType, number>>;
}

export interface PlayerSkillConfig {
  cardId: string;
  tier?: Tier;
}

export interface PlayerConfig {
  type: "player";
  health?: number;
  healthRegen?: number;
  income?: number;
  gold?: number;
  cards?: PlayerCardConfig[];
  skills?: PlayerSkillConfig[];
}

export function getInitialGameState(
  Cards: Cards,
  Encounters: EncounterDays,
  config: (MonsterConfig | PlayerConfig)[],
  randomSeed: number = 1,
): GameState {
  return {
    tick: 0,
    isPlaying: true,
    sandstormStartTick: defaultSandstormInitialTick,
    players: config.map((player) => {
      if (player.type === "monster") {
        if (!player.name) throw new Error("Monster name is required");
        return createBoardPlayerFromMonsterName(Cards, Encounters, player.name);
      } else {
        return createBoardPlayer(
          {
            HealthMax: player.health ?? 3500,
            HealthRegen: player.healthRegen ?? 0,
            Income: player.income ?? 0,
            Gold: player.gold ?? 0,
          },
          (player.cards ?? [])
            .map((c) =>
              createBoardCardFromId(
                Cards,
                c.cardId,
                c.tier,
                c.enchantment,
                c.attributeOverrides,
              ),
            )
            .concat(
              (player.skills ?? []).map((s) =>
                createBoardCardFromId(Cards, s.cardId, s.tier),
              ),
            ),
        );
      }
    }),
    multicast: [],
    randomGen: prand.xoroshiro128plus(randomSeed),
  };
}

export function getFlattenedEncounters(
  Encounters: EncounterDays,
): Array<FlattenedEncounter> {
  return Encounters.data
    .map((data) => {
      return data.groups
        .map((day) => {
          return day.map((group) => ({
            name: group.cardName,
            card: { cardName: group.cardName, cardId: group.cardId },
            day: data.day,
          }));
        })
        .flat();
    })
    .flat();
}
